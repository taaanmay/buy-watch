'use strict';

var IsoWebSocket = require('isomorphic-ws');
var events = require('events');
var universalFetch = require('@inrupt/universal-fetch');
var solidClient = require('@inrupt/solid-client');

//
// Copyright 2022 Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
class FetchError extends Error {
    constructor(url, statusCode, statusText, fetchDescription, response) {
        super(statusText);
        this.message = `Unable to fetch ${fetchDescription}: ${url} returned [${statusCode}] ${statusText}`;
        this.response = response;
    }
}
class NotImplementedError extends Error {
    constructor(message = "Not implemented by base class") {
        super(message);
    }
}
class NotSupported extends Error {
    constructor(cause) {
        super("The server appears to not support notifications");
        if (cause) {
            this.message = `The server appears to not support notifications: ${cause.toString()}`;
            this.cause = cause;
        }
    }
}

//
/**
 * @hidden
 */
class BaseNotification {
    // Dynamically import solid-client-authn-browser so that Notification doesn't have a hard
    // dependency.
    /* eslint consistent-return: 0 */
    /** @internal */
    static async getDefaultSessionFetch() {
        try {
            const { fetch: fetchFn } = await import('@inrupt/solid-client-authn-browser');
            return fetchFn;
        }
        catch (e) {
            /* empty */
        }
    }
    constructor(topic, protocolList, options = {}) {
        /** @internal */
        this.fetchLoaded = false;
        /** @internal */
        this.status = "closed";
        /**
         * Allows setting a [WHATWG Fetch API][fetch] compatible function
         * for making HTTP requests. When [@inrupt/solid-client-authn-browser][scab]
         * is available and this property is not set, `fetch` will be imported from
         * there. Otherwise, the HTTP requests will be unauthenticated.
         *
         * [fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
         *
         * [scab]: https://npmjs.com/package/@inrupt/solid-client-authn-browser
         *
         * @param sessionFetch
         */
        this.setSessionFetch = (sessionFetch = universalFetch.fetch) => {
            this.fetch = sessionFetch;
        };
        const { gateway, features = {}, fetch: fetchFn } = options;
        this.topic = topic;
        this.protocols = protocolList;
        this.features = features;
        this.gateway = gateway;
        // Load fetch:
        this.fetch = universalFetch.fetch;
        this.setSessionFetch();
        this.fetchLoaded = false;
        this.fetchLoader = new Promise((resolve) => {
            // The following breaks JSDom tests, so it isn't tested for and excluded from
            // test coverage.
            /* istanbul ignore next */
            if (fetchFn) {
                this.setSessionFetch(fetchFn);
                resolve();
            }
            else {
                // Attempt to load the fetch function from the default session if no fetchFn was passed in.
                BaseNotification.getDefaultSessionFetch()
                    .then((defaultFetchFn) => {
                    if (defaultFetchFn) {
                        this.setSessionFetch(defaultFetchFn);
                    }
                })
                    .finally(() => {
                    resolve();
                });
            }
        }).then(() => {
            this.fetchLoaded = true;
        });
    }
    /** @internal */
    async fetchNegotiationGatewayUrl() {
        if (this.gateway) {
            return this.gateway;
        }
        const wellKnown = await solidClient.getWellKnownSolid(this.topic, {
            fetch: this.fetch,
        }).catch((err) => {
            // The storage server for the topic resource didn't respond well to
            // getWellKnownSolid requests:
            throw new NotSupported(err);
        });
        const wellKnownSubjects = solidClient.getThingAll(wellKnown, {
            acceptBlankNodes: true,
        });
        const wellKnownSubject = wellKnownSubjects[0];
        // First try reading the 2.0 predicate:
        let notificationGateway = solidClient.getIri(wellKnownSubject, "http://www.w3.org/ns/solid/terms#notificationGateway");
        // Then try the earlier 1.1 predicate:
        if (!notificationGateway) {
            notificationGateway = solidClient.getIri(wellKnownSubject, "http://inrupt.com/ns/ess#notificationGatewayEndpoint");
        }
        // If we don't get either, then error out:
        if (!notificationGateway) {
            throw new NotSupported();
        }
        this.gateway = notificationGateway;
        return notificationGateway;
    }
    /** @internal */
    async fetchProtocolNegotiationInfo() {
        if (!this.fetchLoaded) {
            await this.fetchLoader;
        }
        if (!this.gateway) {
            this.gateway = await this.fetchNegotiationGatewayUrl();
        }
        // Typescript doesn't notice that this.gateway was changed in fetchNegotiationGatewayUrl,
        // so we'll have to ignore it.
        /* eslint @typescript-eslint/ban-ts-comment: 0 */
        // @ts-ignore
        const response = await this.fetch(this.gateway, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                protocols: this.protocols,
                features: Object.keys(this.features),
            }),
        });
        if (response.status !== 200) {
            throw new FetchError(response.url, response.status, response.statusText, "protocol negotiation info", response);
        }
        return response.json();
    }
    /** @internal */
    async fetchNotificationConnectionInfo() {
        if (!this.fetchLoaded) {
            await this.fetchLoader;
        }
        const { endpoint } = await this.fetchProtocolNegotiationInfo();
        const response = await this.fetch(endpoint, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                topic: this.topic,
                ...this.features,
            }),
        });
        if (response.status !== 200) {
            throw new FetchError(response.url, response.status, response.statusText, "connection info", response);
        }
        return response.json();
    }
}

//
/**
 * @hidden
 */
class LiveNotification extends BaseNotification {
    // TODO move constructor options to options instead of arguments
    constructor(topic, protocolList, options) {
        super(topic, protocolList, options);
        this.connect = () => {
            this.status = "closed";
            throw new NotImplementedError();
        };
        this.disconnect = () => {
            this.status = "closed";
            throw new NotImplementedError();
        };
        this.emitter = new events.EventEmitter();
    }
    /* eslint @typescript-eslint/no-explicit-any: 0 */
    on(eventName, listener) {
        this.emitter.on(eventName, listener);
        return this;
    }
    /* eslint @typescript-eslint/no-explicit-any: 0 */
    once(eventName, listener) {
        this.emitter.once(eventName, listener);
        return this;
    }
    /* eslint @typescript-eslint/no-explicit-any: 0 */
    off(eventName, listener) {
        this.emitter.off(eventName, listener);
        return this;
    }
}

//
/**
 * Constructor for a WebSocket Notification instance, which allows subscribing to resources in the solid ecosystem.
 * See the [Solid Notifications Protocol Specification](https://solid.github.io/notifications/protocol) for more details.
 *
 * ```typescript
 * import { getDefaultSession } from '@inrupt/solid-authn-browser';
 * // or for node.js:
 * //   import { Session } from '@inrupt/solid-authn-node';
 *
 * const session = getDefaultSession();
 * // for node.js:
 * //   const session = new Session();
 * //   await session.login({
 * //     oidcIssuer,
 * //     clientId,
 * //     clientSecret,
 * //   });
 *
 * const socket = new WebsocketNotification(parentContainerUrl, {
 *   fetch: session.fetch,
 * });
 *
 * socket.on("message", (notification) => {
 *   console.log("Change:", notification);
 * });
 *
 * // Connect for receiving notifications:
 * await socket.connect();
 *
 * // later:
 * socket.disconnect();
 * ```
 */
class WebsocketNotification extends LiveNotification {
    constructor(topic, options) {
        // Hardcode the protocol to WS to ask the server specifically for a websocket connection
        super(topic, ["ws"], options);
        /** @hidden */
        this.status = "closed";
        /**
         * Connects the websocket to start receiving notifications. If no
         * `providedEndpoint` or `providedSubprotocol` parameter is present, then
         * those will automatically be discovered based on the capabilities of the
         * host of the resource that you're subscribing to notifications for.
         */
        this.connect = async (providedEndpoint, providedSubprotocol) => {
            this.status = "connecting";
            let endpoint = providedEndpoint;
            let subprotocol = providedSubprotocol;
            if (!endpoint) {
                const connectionInfo = await this.fetchNotificationConnectionInfo();
                endpoint = connectionInfo.endpoint;
                subprotocol = connectionInfo.subprotocol;
            }
            this.websocket = new IsoWebSocket(endpoint, subprotocol);
            this.websocket.onopen = () => {
                this.status = "connected";
                this.emitter.emit("connected");
            };
            // We must use onmessage here instead of event listeners, as the `ws`
            // module's events are non-standard:
            this.websocket.onmessage = (e) => {
                // The protocol only transmits JSON as strings, and does not use binary messages
                if (typeof e.data !== "string") {
                    // eslint-disable-next-line no-console
                    console.warn(`Received non-string websocket message, most likely an error:`, e.data);
                    return;
                }
                let payload;
                try {
                    payload = JSON.parse(e.data);
                }
                catch (err) {
                    // eslint-disable-next-line no-console
                    console.warn(`Received non-JSON websocket message, most likely an error:`, e.data, err);
                    return;
                }
                this.emitter.emit("message", payload);
            };
            // TODO auto-reconnect once we get a TTL from notification connection info
            this.websocket.onclose = () => {
                this.status = "closed";
                this.emitter.emit("closed");
            };
            this.websocket.onerror = (e) => {
                this.emitter.emit("error", e);
            };
        };
        this.disconnect = () => {
            if (this.websocket) {
                this.websocket.close();
                this.websocket = undefined;
            }
        };
    }
}

exports.FetchError = FetchError;
exports.NotImplementedError = NotImplementedError;
exports.WebsocketNotification = WebsocketNotification;
