import { fetch } from '@inrupt/universal-fetch';
import { getWellKnownSolid, getThingAll, getIri } from '@inrupt/solid-client';
import { NotSupported, FetchError } from './errors.mjs';

//
/**
 * @hidden
 */
class BaseNotification {
    // Dynamically import solid-client-authn-browser so that Notification doesn't have a hard
    // dependency.
    /* eslint consistent-return: 0 */
    /** @internal */
    static async getDefaultSessionFetch() {
        try {
            const { fetch: fetchFn } = await import('@inrupt/solid-client-authn-browser');
            return fetchFn;
        }
        catch (e) {
            /* empty */
        }
    }
    constructor(topic, protocolList, options = {}) {
        /** @internal */
        this.fetchLoaded = false;
        /** @internal */
        this.status = "closed";
        /**
         * Allows setting a [WHATWG Fetch API][fetch] compatible function
         * for making HTTP requests. When [@inrupt/solid-client-authn-browser][scab]
         * is available and this property is not set, `fetch` will be imported from
         * there. Otherwise, the HTTP requests will be unauthenticated.
         *
         * [fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
         *
         * [scab]: https://npmjs.com/package/@inrupt/solid-client-authn-browser
         *
         * @param sessionFetch
         */
        this.setSessionFetch = (sessionFetch = fetch) => {
            this.fetch = sessionFetch;
        };
        const { gateway, features = {}, fetch: fetchFn } = options;
        this.topic = topic;
        this.protocols = protocolList;
        this.features = features;
        this.gateway = gateway;
        // Load fetch:
        this.fetch = fetch;
        this.setSessionFetch();
        this.fetchLoaded = false;
        this.fetchLoader = new Promise((resolve) => {
            // The following breaks JSDom tests, so it isn't tested for and excluded from
            // test coverage.
            /* istanbul ignore next */
            if (fetchFn) {
                this.setSessionFetch(fetchFn);
                resolve();
            }
            else {
                // Attempt to load the fetch function from the default session if no fetchFn was passed in.
                BaseNotification.getDefaultSessionFetch()
                    .then((defaultFetchFn) => {
                    if (defaultFetchFn) {
                        this.setSessionFetch(defaultFetchFn);
                    }
                })
                    .finally(() => {
                    resolve();
                });
            }
        }).then(() => {
            this.fetchLoaded = true;
        });
    }
    /** @internal */
    async fetchNegotiationGatewayUrl() {
        if (this.gateway) {
            return this.gateway;
        }
        const wellKnown = await getWellKnownSolid(this.topic, {
            fetch: this.fetch,
        }).catch((err) => {
            // The storage server for the topic resource didn't respond well to
            // getWellKnownSolid requests:
            throw new NotSupported(err);
        });
        const wellKnownSubjects = getThingAll(wellKnown, {
            acceptBlankNodes: true,
        });
        const wellKnownSubject = wellKnownSubjects[0];
        // First try reading the 2.0 predicate:
        let notificationGateway = getIri(wellKnownSubject, "http://www.w3.org/ns/solid/terms#notificationGateway");
        // Then try the earlier 1.1 predicate:
        if (!notificationGateway) {
            notificationGateway = getIri(wellKnownSubject, "http://inrupt.com/ns/ess#notificationGatewayEndpoint");
        }
        // If we don't get either, then error out:
        if (!notificationGateway) {
            throw new NotSupported();
        }
        this.gateway = notificationGateway;
        return notificationGateway;
    }
    /** @internal */
    async fetchProtocolNegotiationInfo() {
        if (!this.fetchLoaded) {
            await this.fetchLoader;
        }
        if (!this.gateway) {
            this.gateway = await this.fetchNegotiationGatewayUrl();
        }
        // Typescript doesn't notice that this.gateway was changed in fetchNegotiationGatewayUrl,
        // so we'll have to ignore it.
        /* eslint @typescript-eslint/ban-ts-comment: 0 */
        // @ts-ignore
        const response = await this.fetch(this.gateway, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                protocols: this.protocols,
                features: Object.keys(this.features),
            }),
        });
        if (response.status !== 200) {
            throw new FetchError(response.url, response.status, response.statusText, "protocol negotiation info", response);
        }
        return response.json();
    }
    /** @internal */
    async fetchNotificationConnectionInfo() {
        if (!this.fetchLoaded) {
            await this.fetchLoader;
        }
        const { endpoint } = await this.fetchProtocolNegotiationInfo();
        const response = await this.fetch(endpoint, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                topic: this.topic,
                ...this.features,
            }),
        });
        if (response.status !== 200) {
            throw new FetchError(response.url, response.status, response.statusText, "connection info", response);
        }
        return response.json();
    }
}

export { BaseNotification };
