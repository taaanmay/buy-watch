import IsoWebSocket from 'isomorphic-ws';
import { LiveNotification } from './liveNotification.mjs';

//
/**
 * Constructor for a WebSocket Notification instance, which allows subscribing to resources in the solid ecosystem.
 * See the [Solid Notifications Protocol Specification](https://solid.github.io/notifications/protocol) for more details.
 *
 * ```typescript
 * import { getDefaultSession } from '@inrupt/solid-authn-browser';
 * // or for node.js:
 * //   import { Session } from '@inrupt/solid-authn-node';
 *
 * const session = getDefaultSession();
 * // for node.js:
 * //   const session = new Session();
 * //   await session.login({
 * //     oidcIssuer,
 * //     clientId,
 * //     clientSecret,
 * //   });
 *
 * const socket = new WebsocketNotification(parentContainerUrl, {
 *   fetch: session.fetch,
 * });
 *
 * socket.on("message", (notification) => {
 *   console.log("Change:", notification);
 * });
 *
 * // Connect for receiving notifications:
 * await socket.connect();
 *
 * // later:
 * socket.disconnect();
 * ```
 */
class WebsocketNotification extends LiveNotification {
    constructor(topic, options) {
        // Hardcode the protocol to WS to ask the server specifically for a websocket connection
        super(topic, ["ws"], options);
        /** @hidden */
        this.status = "closed";
        /**
         * Connects the websocket to start receiving notifications. If no
         * `providedEndpoint` or `providedSubprotocol` parameter is present, then
         * those will automatically be discovered based on the capabilities of the
         * host of the resource that you're subscribing to notifications for.
         */
        this.connect = async (providedEndpoint, providedSubprotocol) => {
            this.status = "connecting";
            let endpoint = providedEndpoint;
            let subprotocol = providedSubprotocol;
            if (!endpoint) {
                const connectionInfo = await this.fetchNotificationConnectionInfo();
                endpoint = connectionInfo.endpoint;
                subprotocol = connectionInfo.subprotocol;
            }
            this.websocket = new IsoWebSocket(endpoint, subprotocol);
            this.websocket.onopen = () => {
                this.status = "connected";
                this.emitter.emit("connected");
            };
            // We must use onmessage here instead of event listeners, as the `ws`
            // module's events are non-standard:
            this.websocket.onmessage = (e) => {
                // The protocol only transmits JSON as strings, and does not use binary messages
                if (typeof e.data !== "string") {
                    // eslint-disable-next-line no-console
                    console.warn(`Received non-string websocket message, most likely an error:`, e.data);
                    return;
                }
                let payload;
                try {
                    payload = JSON.parse(e.data);
                }
                catch (err) {
                    // eslint-disable-next-line no-console
                    console.warn(`Received non-JSON websocket message, most likely an error:`, e.data, err);
                    return;
                }
                this.emitter.emit("message", payload);
            };
            // TODO auto-reconnect once we get a TTL from notification connection info
            this.websocket.onclose = () => {
                this.status = "closed";
                this.emitter.emit("closed");
            };
            this.websocket.onerror = (e) => {
                this.emitter.emit("error", e);
            };
        };
        this.disconnect = () => {
            if (this.websocket) {
                this.websocket.close();
                this.websocket = undefined;
            }
        };
    }
}

export { WebsocketNotification };
