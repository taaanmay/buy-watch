"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = exports.defaultStorage = void 0;
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const uuid_1 = require("uuid");
const universal_fetch_1 = require("@inrupt/universal-fetch");
const events_1 = __importDefault(require("events"));
const dependencies_1 = require("./dependencies");
exports.defaultStorage = new solid_client_authn_core_1.InMemoryStorage();
class Session extends events_1.default {
    constructor(sessionOptions = {}, sessionId = undefined) {
        super();
        this.tokenRequestInProgress = false;
        this.lastTimeoutHandle = 0;
        this.login = async (options) => {
            const loginInfo = await this.clientAuthentication.login(this.info.sessionId, {
                ...options,
            }, this.events);
            if (loginInfo !== undefined) {
                this.info.isLoggedIn = loginInfo.isLoggedIn;
                this.info.sessionId = loginInfo.sessionId;
                this.info.webId = loginInfo.webId;
                this.info.expirationDate = loginInfo.expirationDate;
            }
            if (loginInfo === null || loginInfo === void 0 ? void 0 : loginInfo.isLoggedIn) {
                this.events.emit(solid_client_authn_core_1.EVENTS.LOGIN);
            }
        };
        this.fetch = async (url, init) => {
            if (!this.info.isLoggedIn) {
                return (0, universal_fetch_1.fetch)(url, init);
            }
            return this.clientAuthentication.fetch(url, init);
        };
        this.logout = async () => this.internalLogout(true);
        this.internalLogout = async (emitEvent) => {
            await this.clientAuthentication.logout(this.info.sessionId);
            clearTimeout(this.lastTimeoutHandle);
            this.info.isLoggedIn = false;
            if (emitEvent) {
                this.events.emit(solid_client_authn_core_1.EVENTS.LOGOUT);
            }
        };
        this.handleIncomingRedirect = async (url) => {
            let sessionInfo;
            if (this.info.isLoggedIn) {
                sessionInfo = this.info;
            }
            else if (this.tokenRequestInProgress) {
            }
            else {
                try {
                    this.tokenRequestInProgress = true;
                    sessionInfo = await this.clientAuthentication.handleIncomingRedirect(url, this.events);
                    if (sessionInfo) {
                        this.info.isLoggedIn = sessionInfo.isLoggedIn;
                        this.info.webId = sessionInfo.webId;
                        this.info.sessionId = sessionInfo.sessionId;
                        if (sessionInfo.isLoggedIn) {
                            this.events.emit(solid_client_authn_core_1.EVENTS.LOGIN);
                        }
                    }
                }
                finally {
                    this.tokenRequestInProgress = false;
                }
            }
            return sessionInfo;
        };
        this.events = new Proxy(this, (0, solid_client_authn_core_1.buildProxyHandler)(Session.prototype, "events only implements ISessionEventListener"));
        if (sessionOptions.clientAuthentication) {
            this.clientAuthentication = sessionOptions.clientAuthentication;
        }
        else if (sessionOptions.storage) {
            this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({
                secureStorage: sessionOptions.storage,
                insecureStorage: sessionOptions.storage,
            });
        }
        else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {
            this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({
                secureStorage: sessionOptions.secureStorage,
                insecureStorage: sessionOptions.insecureStorage,
            });
        }
        else {
            this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({
                secureStorage: exports.defaultStorage,
                insecureStorage: exports.defaultStorage,
            });
        }
        if (sessionOptions.sessionInfo) {
            this.info = {
                sessionId: sessionOptions.sessionInfo.sessionId,
                isLoggedIn: false,
                webId: sessionOptions.sessionInfo.webId,
            };
        }
        else {
            this.info = {
                sessionId: sessionId !== null && sessionId !== void 0 ? sessionId : (0, uuid_1.v4)(),
                isLoggedIn: false,
            };
        }
        if (sessionOptions.onNewRefreshToken !== undefined) {
            this.events.on(solid_client_authn_core_1.EVENTS.NEW_REFRESH_TOKEN, sessionOptions.onNewRefreshToken);
        }
        this.events.on(solid_client_authn_core_1.EVENTS.TIMEOUT_SET, (timeoutHandle) => {
            this.lastTimeoutHandle = timeoutHandle;
        });
        this.events.on(solid_client_authn_core_1.EVENTS.ERROR, () => this.internalLogout(false));
        this.events.on(solid_client_authn_core_1.EVENTS.SESSION_EXPIRED, () => this.internalLogout(false));
    }
    onLogin(callback) {
        this.events.on(solid_client_authn_core_1.EVENTS.LOGIN, callback);
    }
    onLogout(callback) {
        this.events.on(solid_client_authn_core_1.EVENTS.LOGOUT, callback);
    }
    onNewRefreshToken(callback) {
        this.events.on(solid_client_authn_core_1.EVENTS.NEW_REFRESH_TOKEN, callback);
    }
}
exports.Session = Session;
//# sourceMappingURL=Session.js.map